// 자바스크립트는 비동기 처리를 위한 하나의 패턴으로 콜백 함수를 사용한다. 하지만 전통적인 콜백 패턴은 콜백 헬로 인해 
//가독성이 나쁘고 비동기 처리 중 발생한 에러의 처리가 곤란하며 여러 개의 비동기 처리를 한번에 처리하는 데도 한계가 있다.
//ES6 에서는 비동기 처리를 위한 또 다른 패턴으로 프로미스를 도입했다. 프로미스는 전통적인 콜백 패턴이 가진 단점을 보완하며 비동기 처리 시점을 명확하게 표현할 수 있다는 장점이 있다.

// function get(url) {
//   화살표함수 해석 -> GET 요청을 보내고 데이터를 가져오는 코드 작성
// }
const get = url => {   
  const xhr = new XMLHttpRequest();
  xhr.open('GET', url);
  xhr.send();

// funtion xhr.onload(){}
xhr.onload =() => {
if (xhr.status === 200){
  console.log(JSON.parse(xhr.response));
}else{
  console.error(`${xhr.status}${xhr.statusText}`)
}
};
};

get('https://jsonplaceholder.typicode.com/post/1');

//get 함수는 서버의 응답 결과를 콘솔에 출력한다. 
//get 함수는 비동기 함수다. 비동기 함수를 호출하면 함수 내부의 비동기로 동작하는 코드가 완료되지 않았다해도
//기다리지 않고 즉시 종료된다. 즉 비동기로 동작하는 코드는 비동기 함수가 종료된 이후에 완료된다. 따라서 비동기 함수 내부의
//비동기로 동작하는 코드에서 처리 결과를 외부로 반환하거나 상위 스코프의 변수에 할당하면 기대한 대로 동작하지 않는다.
//예를 들어 , settimeout 함수는 비동기 함수다. 비동기 함수인 이유는 콜백함수의 호출이 비동기로 동작하기 때문이다.

let g = 0;
//비동기 함수인 settimeout은 콜백 함수의 처리 결과를 외부로 반환하거나 상위 스코프의 변수에 할당하지 못한다.
setTimeout(()=>{g =100; 
  console.log(g); //100
  g=300;
  console.log(g); //300
},3000);


// setTimeout(function() {
//   g = 100;
// }, 0);
// setTimeout() 함수는 첫 번째 인자로 전달된 콜백 함수를, 두 번째 인자로 전달된 밀리초 단위의 시간이 지난 이후에 실행합니다. 여기서 두 번째 인자로 0을 전달하였으므로, 현재 실행 중인 코드가 끝난 다음에 즉시 콜백 함수가 실행됩니다. 이때, 콜백 함수에서는 g 변수를 100으로 설정하고 있습니다.

// 즉, 해당 코드는 현재 실행 중인 코드가 끝난 다음에 g 변수를 100으로 설정하는 작업을 예약하는 것이며, 이는 이벤트 루프가 동작하는 원리를 기반으로 합니다.
// console.log(g); 

console.log(g); //0


